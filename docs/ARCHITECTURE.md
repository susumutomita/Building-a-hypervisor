# ハイパーバイザーの仕組み - ステップバイステップ解説

このドキュメントでは、macOS Hypervisor.framework を使用したハイパーバイザーの動作原理とコードの詳細を解説する。

## 目次

1. [ハイパーバイザーとは](#ハイパーバイザーとは)
2. [全体アーキテクチャ](#全体アーキテクチャ)
3. [コード解説](#コード解説)
4. [ARM64 命令の詳細](#arm64-命令の詳細)
5. [VM Exit の仕組み](#vm-exit-の仕組み)

---

## ハイパーバイザーとは

ハイパーバイザーは、物理ハードウェア上で複数の仮想マシン (VM) を実行するためのソフトウェア層である。

```
┌─────────────────────────────────────────────────┐
│                  ゲスト OS                       │
│  (仮想マシン内で動作するコード)                    │
├─────────────────────────────────────────────────┤
│               ハイパーバイザー                    │
│  (VM の作成、メモリ管理、CPU 仮想化)              │
├─────────────────────────────────────────────────┤
│           Hypervisor.framework                  │
│  (macOS が提供するハイパーバイザー API)           │
├─────────────────────────────────────────────────┤
│              ハードウェア (CPU)                  │
│  (ARM64 の仮想化支援機能)                        │
└─────────────────────────────────────────────────┘
```

### なぜハードウェア仮想化が必要か

従来のエミュレーション（QEMU など）は、すべての命令をソフトウェアで解釈・実行するため遅い。ハードウェア仮想化では、CPU が直接ゲストコードを実行し、特権命令や I/O アクセス時のみハイパーバイザーに制御を戻す（VM Exit）。これにより、ほぼネイティブに近い速度で仮想マシンを実行できる。

---

## 全体アーキテクチャ

### 実行フロー

```
┌──────────────────┐
│  1. VM 作成       │  VirtualMachine::new()
└────────┬─────────┘
         ▼
┌──────────────────┐
│  2. vCPU 作成     │  Vcpu::new()
└────────┬─────────┘
         ▼
┌──────────────────┐
│  3. メモリ確保    │  Mapping::new() + map()
└────────┬─────────┘
         ▼
┌──────────────────┐
│  4. コード書込み   │  write_dword()
└────────┬─────────┘
         ▼
┌──────────────────┐
│  5. レジスタ設定  │  set_reg(PC, CPSR)
└────────┬─────────┘
         ▼
┌──────────────────┐
│  6. vCPU 実行     │  vcpu.run()
└────────┬─────────┘
         ▼
    ┌────┴────┐
    ▼         ▼
 ゲスト     VM Exit
 コード    (例外発生)
 実行         │
    │         ▼
    │    ┌──────────────┐
    │    │ Exit 処理     │
    │    │ (理由を判定)   │
    │    └──────┬───────┘
    │           │
    └───────────┘
       (ループ)
```

### 主要コンポーネント

| コンポーネント | 役割 |
|--------------|------|
| `VirtualMachine` | VM 全体を管理。プロセスごとに 1 つのみ作成可能 |
| `Vcpu` | 仮想 CPU。レジスタ状態を保持し、ゲストコードを実行 |
| `Mapping` | ゲストメモリ領域。ホストメモリをゲストアドレス空間にマップ |

---

## コード解説

### Step 1: VirtualMachine の作成

```rust
let _vm = VirtualMachine::new()?;
```

**何が起きているか:**

1. Hypervisor.framework の `hv_vm_create()` を呼び出す
2. カーネルが仮想化支援機能を初期化
3. プロセスに VM コンテキストが割り当てられる

**制約:**
- 1 プロセスにつき 1 VM のみ
- `com.apple.security.hypervisor` エンタイトルメントが必要

**なぜ `_vm` とアンダースコアをつけているか:**
- 変数を直接使用しないが、スコープ内で VM を維持する必要がある
- `_vm` がドロップされると VM が破棄される

---

### Step 2: vCPU の作成

```rust
let vcpu = Vcpu::new()?;
```

**何が起きているか:**

1. `hv_vcpu_create()` を呼び出す
2. 仮想 CPU のコンテキスト（レジスタ、状態）が作成される
3. vCPU は独自のスレッドで実行可能（今回は単一スレッド）

**vCPU の状態:**

```
┌─────────────────────────────────┐
│           vCPU                  │
├─────────────────────────────────┤
│  汎用レジスタ: X0-X30           │
│  PC (プログラムカウンタ)         │
│  SP (スタックポインタ)           │
│  CPSR (ステータスレジスタ)       │
│  システムレジスタ群              │
└─────────────────────────────────┘
```

---

### Step 3: ゲストメモリのマッピング

```rust
let guest_addr: u64 = 0x10000;
let mem_size: usize = 0x1000; // 4KB

let mut mem = Mapping::new(mem_size)?;
mem.map(guest_addr, MemPerms::RWX)?;
```

**何が起きているか:**

1. `Mapping::new(0x1000)`: ホスト側で 4KB のメモリを確保
2. `mem.map(0x10000, RWX)`: そのメモリをゲストアドレス `0x10000` にマップ

**メモリマッピングの構造:**

```
ホスト側                        ゲスト側
(物理メモリ)                    (仮想アドレス空間)

┌──────────┐                   ┌──────────┐
│          │                   │          │
│  heap    │                   │ 0x00000  │ (未マップ)
│          │                   │          │
├──────────┤ ◄─── マップ ────► ├──────────┤
│  4KB     │                   │ 0x10000  │ ゲストコード
│  確保    │                   │          │ が実行される
├──────────┤                   ├──────────┤
│          │                   │ 0x11000  │ (未マップ)
└──────────┘                   └──────────┘
```

**MemPerms::RWX の意味:**
- **R** (Read): 読み取り可能
- **W** (Write): 書き込み可能
- **X** (Execute): 実行可能

コードを実行するため、実行権限 (X) が必須。

---

### Step 4: ゲストコードの書き込み

```rust
// mov x0, #42 (0xD2800540)
mem.write_dword(guest_addr, 0xD2800540)?;
// brk #0 (0xD4200000)
mem.write_dword(guest_addr + 4, 0xD4200000)?;
```

**何が起きているか:**

ARM64 の機械語命令を直接メモリに書き込んでいる。

**メモリ上の配置:**

```
アドレス      内容              命令
0x10000      D2 80 05 40      mov x0, #42
0x10004      D4 20 00 00      brk #0
```

各命令は 4 バイト（32 ビット）固定長。

---

### Step 5: vCPU レジスタの設定

```rust
vcpu.set_reg(Reg::PC, guest_addr)?;    // PC = 0x10000
vcpu.set_reg(Reg::CPSR, 0x3c4)?;       // CPSR = EL1h モード
vcpu.set_trap_debug_exceptions(true)?;
```

**各レジスタの役割:**

#### PC (Program Counter)
- 次に実行する命令のアドレス
- `0x10000` に設定 → ゲストコードの先頭から実行開始

#### CPSR (Current Program Status Register)
- CPU の動作モードと状態フラグを保持
- `0x3c4` の意味:

```
CPSR = 0x3c4 = 0b0000_0011_1100_0100

ビット    意味
[3:0]     M[3:0] = 0100 (EL1h)
[4]       M[4] = 0
[5]       (reserved)
[6]       F = 1 (FIQ マスク)
[7]       I = 1 (IRQ マスク)
[8]       A = 1 (SError マスク)
[9]       D = 1 (Debug マスク)
```

**EL1h モードとは:**
- Exception Level 1 (カーネルモード相当)
- "h" は Handler モード（SP_EL1 を使用）
- ゲスト OS カーネルが動作する権限レベル

```
┌─────────────────────────────────┐
│  EL3: Secure Monitor            │  (最高権限)
├─────────────────────────────────┤
│  EL2: Hypervisor                │  ← ハイパーバイザーが動作
├─────────────────────────────────┤
│  EL1: OS Kernel                 │  ← ゲストコードが動作
├─────────────────────────────────┤
│  EL0: User Application          │  (最低権限)
└─────────────────────────────────┘
```

#### set_trap_debug_exceptions(true)
- BRK 命令などのデバッグ例外を VM Exit としてトラップ
- これがないと BRK 命令でゲスト内で例外処理される

---

### Step 6: vCPU の実行と VM Exit ループ

```rust
loop {
    vcpu.run()?;
    let exit_info = vcpu.get_exit_info();
    // ...
}
```

**vcpu.run() の動作:**

1. CPU コンテキストをゲストモードに切り替え
2. ゲストコードを実行
3. VM Exit が発生するまで実行を継続
4. Exit 情報を記録して制御を返す

**VM Exit ループの構造:**

```
┌─────────────────────────────────────────────────────┐
│                    ホスト側                          │
│                                                     │
│   ┌─────────────┐                                   │
│   │ vcpu.run()  │ ──────────────────────┐           │
│   └─────────────┘                       │           │
│         ▲                               ▼           │
│         │                    ┌──────────────────┐   │
│         │                    │  ゲストコード実行  │   │
│         │                    │  (mov x0, #42)   │   │
│         │                    │  (brk #0)        │   │
│         │                    └────────┬─────────┘   │
│         │                             │             │
│         │                      VM Exit (例外)       │
│         │                             │             │
│         │                             ▼             │
│   ┌─────┴─────────────────────────────────────┐     │
│   │              Exit 処理                     │     │
│   │  - exit_info を取得                        │     │
│   │  - 例外の種類を判定                        │     │
│   │  - BRK なら終了、それ以外は継続            │     │
│   └───────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────┘
```

---

### Exit 情報の解析

```rust
if let applevisor::ExitReason::EXCEPTION = exit_info.reason {
    let syndrome = exit_info.exception.syndrome;
    let ec = (syndrome >> 26) & 0x3f;

    if ec == 0x3C {
        // BRK 命令を検出
        break;
    }
}
```

**Exception Syndrome Register (ESR) の構造:**

```
syndrome = 0xf2000000

ビット      フィールド      値
[31:26]     EC             0x3C (BRK instruction)
[25]        IL             1 (32-bit instruction)
[24:0]      ISS            0x000000 (BRK #0)
```

**EC (Exception Class) の主な値:**

| EC | 例外の種類 |
|----|----------|
| 0x00 | Unknown |
| 0x15 | SVC (Supervisor Call) |
| 0x16 | HVC (Hypervisor Call) |
| 0x17 | SMC (Secure Monitor Call) |
| 0x20 | Instruction Abort (lower EL) |
| 0x24 | Data Abort (lower EL) |
| 0x3C | BRK instruction (AArch64) |

---

## ARM64 命令の詳細

### mov x0, #42 (0xD2800540)

```
0xD2800540 = 0b1101_0010_1000_0000_0000_0101_0100_0000

ビット      フィールド      値          意味
[31]        sf             1           64-bit (X レジスタ)
[30:29]     opc            10          MOVZ
[28:23]     100101         固定
[22:21]     hw             00          シフトなし
[20:5]      imm16          0x002A      即値 42 (0x2A = 42)
[4:0]       Rd             00000       X0 レジスタ
```

**MOVZ 命令:**
- レジスタをゼロクリアしてから即値を移動
- `mov x0, #42` は `movz x0, #42, lsl #0` と等価

### brk #0 (0xD4200000)

```
0xD4200000 = 0b1101_0100_0010_0000_0000_0000_0000_0000

ビット      フィールド      値          意味
[31:24]     11010100       固定
[23:21]     001            BRK
[20:5]      imm16          0x0000      即値 0
[4:0]       00000          固定
```

**BRK 命令:**
- ソフトウェアブレークポイント
- デバッガやハイパーバイザーへの制御転送に使用
- 即値はデバッガが識別に使用可能

---

## VM Exit の仕組み

### なぜ VM Exit が必要か

ゲストコードは基本的に自由に実行されるが、以下の場合はハイパーバイザーの介入が必要:

1. **特権命令**: システムレジスタへのアクセス
2. **I/O アクセス**: デバイスへの読み書き
3. **例外**: BRK、HVC、未定義命令など
4. **割り込み**: タイマー、外部割り込み

### 今回の VM Exit フロー

```
時間 ─────────────────────────────────────────────────────►

     ホスト                         ゲスト
       │                              │
       │  vcpu.run()                  │
       │ ────────────────────────────►│
       │                              │
       │                              │ mov x0, #42
       │                              │ (X0 = 42 に設定)
       │                              │
       │                              │ brk #0
       │                              │ (例外発生!)
       │                              │
       │◄──────────────────────────── │
       │  VM Exit (EXCEPTION)         │
       │                              │
       │  exit_info を解析            │
       │  EC = 0x3C (BRK)             │
       │  X0 = 42 を確認              │
       │                              │
       ▼                              ▼
     終了
```

### 実行結果の意味

```
VM Exit:
  - Reason: EXCEPTION
  - PC: 0x10004           ← BRK 命令の次のアドレス
  - X0: 42 (0x2a)         ← mov x0, #42 の結果
  - Exception Syndrome: 0xf2000000
  - Exception Class (EC): 0x3c  ← BRK 命令

✓ BRK 命令を検出!
  ゲストが x0 = 42 を設定して BRK を呼び出しました。
```

1. `mov x0, #42` が実行され、X0 レジスタに 42 が格納された
2. `brk #0` が実行され、デバッグ例外が発生
3. VM Exit が発生し、ホスト側に制御が戻った
4. ホスト側で X0 = 42 を確認できた

---

## まとめ

このハイパーバイザーは以下を実証している:

1. **ハードウェア仮想化**: CPU の仮想化支援機能を使用してゲストコードを直接実行
2. **メモリ仮想化**: ホストメモリをゲストアドレス空間にマップ
3. **VM Exit ハンドリング**: ゲストからホストへの制御転送と状態取得
4. **レジスタ操作**: ゲスト CPU レジスタの読み書き

この基盤の上に、I/O エミュレーション、割り込み処理、ページング設定などを追加することで、本格的な VM（Linux カーネルの起動など）が実現できる。
